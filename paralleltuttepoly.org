#+title: Parallel Computation of the Tutte Polynomial
#+subtitle: 15-418: Project #71
#+author: Akira Kyle
#+date: April 18, 2018
#+email: akyle@cmu.edu
#+options: toc:nil email:t
#+latex_header_extra: \pagestyle{fancy}
#+latex_header_extra: \fancyhead[R]{Akira Kyle}
#+latex_header_extra: \fancyhead[L]{15-418}
#+latex_header_extra: \fancyhead[C]{Parallel Computation of the Tutte Polynomial}
#+latex_header_extra: \fancyfoot[C]{\thepage}

* Links
** Tutte background
[[https://en.wikipedia.org/wiki/Tutte_polynomial]]
Brendan McKay Nauty and Traces [[http://pallini.di.uniroma1.it/]]
Haggard C++ tuttepoly code [[http://homepages.ecs.vuw.ac.nz/~djp/tutte/]]
Mathematica tutte polynomial function [[http://reference.wolfram.com/language/ref/TuttePolynomial.html]]
Monagan maple tutte polynomial code [[http://www.cecm.sfu.ca/~mmonagan/tutte/]]
Vertex-exponential time tutte polynomial [[https://github.com/thorehusfeldt/tutte_bhkk]]
Blog post using tutte_bhkk in python [[http://mhenderson.net/page3/]]
** Five-flow
https://symomega.wordpress.com/2010/06/13/roots-of-flow-polynomials-and-welshs-conjecture/

** Fortran
http://www.featflow.de/en/software/featflow2/tutorial/tutorial_lang.html
https://en.wikibooks.org/wiki/Fortran
http://www.cs.rpi.edu/~szymansk/OOF90/bugs.html
http://kitchingroup.cheme.cmu.edu/blog/2014/02/04/Literate-programming-example-with-Fortran-and-org-mode/


* Project proposal
** Summary
 I will implement and optimize an algorithm to compute the Tutte Polynomial for
 arbitrary graphs using both MPI and openMP. I will examine the effect of
 different edge selection heuristics on the performance scaling of the program. 

** Background
 In the search for a proof to the four color theorem, the mathematician George
 David Birkhoff came up with the Chromatic Polynomial which counts the number of
 possible colorings of a graph as a function of $k$ possible colors to color it
 with. If one can show that this polynomial is positive for all planar graphs
 when $k=4$, then one proves the four color theorem. While it didn't prove useful
 in actually proving the four color theorem, W.T. Tutte generalized this
 chromatic polynomial to the Tutte Polynomial which has become an important Graph
 invariant that has been related to results from knot theory, combinatorics, and
 statistical physics. 

 The Tutte Polynomial can be defined recursively using edge contraction ($G/e$)
 and edge deletion ($G - e$) on an undirected graph $G$ as

 \[T_G(x,y) = T_{G-e}(x,y) + T_{G/e}(x,y)\]

 where $e$ must be neither a bridge nor a loop. The base case being when $G$
 contains only $i$ bridges and $j$ loops is $T_G(x,y) = x^iy^j$

 The Tutte polynomial can also be given in closed form for a graph $G = (V, E)$
 by:

 \[T_G(x,y) = \sum_A\subseteq E (x-1)^{k(A) - k(E)}(y-1)^{k(A) + |A| - |V|}\] 

 Where $k(A)$ is the number of connected components of $(V,A)$. 

 From this statement of the Tutte polynomial one can guess that it happens to #P
 hard, as the sum is over the power set of the edges. Evaluating the it a various
 points yields various results of interest, for example $y=0$ gives the chromatic
 polynomial. The Wikipedia page has a good summary of this discussion
 ([[https://en.wikipedia.org/wiki/Tutte_polynomial]]).

** The Challenge

 Between the two definitions given above, the recursive definition is the most
 promising for implementing a fast algorithm. This is because it naturally
 creates a computation tree with potentially redundant computation being
 performed along some branches which we can use Dynamic Programming ideas to
 speedup. The following illustration (taken from the wikipedia article)
 illustrates an example of calculating the Tutte polynomial using the recursive
 deletion-contraction definition.

 #+attr_latex: :width 4in
 [[file:figs/Deletion-contraction.svg]]

 To find branches with redundant computation we need to be able to identify
 isomorphic graphs. One of the most prominent programs for doing so is the nauty
 and Traces program written by Brendan McKay ([[http://pallini.di.uniroma1.it/]]).
 This program can output a canonical labeling for a graph which can then be used
 as a key in a graph cache.

 The interesting issues to consider in paralleling this will be surrounding this
 cache as it is the central part to speeding up this otherwise intractable
 computation. Sharing this cache safely and efficiently across all the processes
 in MPI may be difficult and might benefit from compressing the graphs. Also
 locking the cache data structure within a process in openMP when it needs to be
 updated will be tricky to keep the overhead low.

 Furthermore while each of the two recursive calls can be done in parallel, it is
 not guaranteed that each will have an equal division of work, especially if one
 side ends up having more cache hits than the other, so scheduling will be
 another issue that will likely have to be done dynamically, potentially with
 some type of work queue. Hiding latency can be a potential area for speedups
 since finding the graph isomorphisms is a relatively compute intensive process
 while the cache lookup and additions are a memory intensive process. Finally the
 usual

** Resources
 /Computing Tutte Polynomials/ by Gary Haggard, David J. Pearce, and Gordon Royle
 (2010) will probably be the basis of my implementation as they seem to have the
 ``current'' best implementation. Their code is available on David Pearce’s web-
 site at [[http://homepages.ecs.vuw.ac.nz/~djp/tutte/]] and is implemented in C++.
 This will serve as my reference to check against for both correctness and
 sequential performance, however I will likely rewrite this from scratch in
 fortran (since I'll be spending my summer internship in fortran so I'd like to
 get some practice) to ensure I understand the algorithm completely (it's not a
 very substantial amount of code). Like their implementation, I will use Brendan
 McKay's nauty for finding graph isomorphisms.

 I may also checkout Mathematica's function to compute the Tutte polynomial as
 another benchmark to compare to
 ([[http://reference.wolfram.com/language/ref/TuttePolynomial.html]]).

 Furthermore a more recent paper /A new edge selection heuristic for computing
 the Tutte polynomial of an undirected graph./ by Michael Monagan (2018) proposes
 a different heuristic from those of Haggard, Pearce, Royale that Monagan claims
 offers massive speedups on many types of graphs. His implementation is in Maple
 and is available at [[http://www.cecm.sfu.ca/~mmonagan/tutte/]].

 Finally an older paper /Computing the Tutte Polynomial in Vertex-Exponential
 Time/ by Andreas Björklund, Thore Husfeldt, Petteri Kaski, Mikko Koivisto (2008)
 which is referenced by Haggard, Pearce, Royle has code available here
 [[https://github.com/thorehusfeldt/tutte_bhkk]] along with a nice blog post
 using it here [[http://mhenderson.net/page3/]].

 I think between the latedays cluster and the ghc machines, I will be sufficient
 hardware to perform scaling experiments and performance assessments.

** Goals and Deliverables
*** Plan to achieve
 - A complete working program using MPI capable of correctly computing Tutte
   polynomials at speeds comparable to the reference implementations and with
   good performance scaling .
 - The three edge selection heuristics (2 from Haggard, Pearce, Royle, 1 from
   Monagan) implemented and a comparison of their performance scaling.

*** Hope to achieve
 - Verifying the result listed of Pearce's website of the Tutte polynomial of the
   Truncated Icosahedron.

 Haggard, Pearce, Royle claim it took one week on 150 machines to calculate,
 however Monagan claims it took four minutes on a single cpu using his edge
 selection heuristic. I would like to be able to meet and exceed both of these
 benchmarks for performance however its difficult to specify a speedup since
 Pearce doesn't list the machine specs used, however given this was achieved in
 2009, I expect the specs on the latedays cluster to be much better. As for the
 Monagan result, since he implemented this in Mapel using no isomorphism test, I
 would hope to get at least a 2x speedup (conservative) due to not having the
 overhead of the maple runtime and additional speedup of from additional pruning
 the computation tree due to isomorphisms.

 - An openMP implementation to compare with the MPI implementation.
 - A combined MPI and openMP implementation to compare to the individual
   implementations.

** Platform Choice
 I will use fortran (since I'll be spending my summer internship in fortran so
 I'd like to get some practice) and MPI and openMP and run on the latedays
 cluster and ghc machines. For this type of application MPI is the most important
 to utilize since to have hope to scale to really massive graphs exceeding what
 can be held in memory by a single machine, it is necessary to use a distributed
 model.

** Schedule
 - Week of April 16th
   - Test harness and sequential implementation
   - Understanding of nauty canonical labeling format and code to interface with
     it (necessary for graph cache)
 - Week of April 23rd
   - Parallel MPI implementation with graph cache and Haggard, Pearce, Royle
     heuristics 
 - Week of April 30th
   - Parallel OpenMP implementation with Monagan heuristic.


* Nauty info

#+begin_example
$ ./nautest 
NAUTYVERSION=2.6 (64 bits)  NAUTYVERSIONID=26040  HAVE_TLS=0
MAXN=0  MAXM=0  WORDSIZE=64  NAUTY_INFINITY=2000000002
sizes: short=2 int=4 long=8 double=8 boolean=4 setword=8
CLZ=1,1,1  POPCNT=1,1,1;0,0
LONG_LONG_COUNTERS=0  COUNTER_FMT=%lu
defined: __STDC__ SETWORD_LONG
DOPROMPT(stdin)=1 DOPROMPT(stdout)=1
CPUTIME = 0.000000
INITSEED: seed=416931912
#+end_example


* Code
** .gitignore
#+begin_src .gitignore :tangle .gitignore
# Ignore everything
*
# except this literate org file
!paralleltuttepoly.org
#+end_src

** Makefile
#+begin_src makefile :tangle Makefile
nauty/nauty.a:
	$(MAKE) -C nauty nauty.a

tutte: nauty/nauty.h nauty/nauty.a tutte.c
	gcc -std=gnu99 -g -o tutte tutte.c nauty/nauty.a -Inauty

# tutte: tutte.c nauty/nausparse.h nauty/nausparse.c
# 	gcc -o tutte tutte.c nauty/nausparse.c -Inauty

execute: tutte
	./tutte graphs/edge10.g6

clean:
	$(MAKE) -C nauty clean
	rm -f tutte *.o

sync:
#	rsync -azP --no-perms ~/class/parallel/asst4-s18 latedays:
	rsync -azP --no-perms ~/class/parallel/project/paralleltuttepoly andrew:
	rsync -azP --no-perms ~/class/parallel/project/nauty26r10 andrew:
#+end_src

** tests
#+begin_src bash :results raw drawer
gsed -e 's/,/\n/g' -e 's/--/:/g' -e '1i\n=10 g' -e '$a\.\n' graphs/edge10 | nauty/dretog > graphs/edge10.g6
cat graphs/edge10.g6
#gsed -e 's/,/\n/g' -e 's/--/:/g' -e '1i\n=10 g' -e '$a\.\nt' edge10 | nauty/dreadnaut
#+end_src

#+RESULTS:
:RESULTS:
I|eMID@WG
:END:

** includes
#+name: includes
#+begin_src c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

 /* MAXN=0 is defined by nauty.h, which implies dynamic allocation */
#include "nauty.h"
#include "gtools.h"
#include "gutils.h"
#+end_src

** macros
#+name: macros
#+begin_src c
#define USAGE "Usage: tutte [-h] [-q] [-p#] [infile [outfile]]\n"

#define HELPTEXT \
" Computes the Tutte polynomial of a graph.\n\
\n\
    infile  the input graph file in either graph6 or sparse6 format.\n\
\n\
    outfile  the output file for the computed polynomial.\n\
\n\
    -p#  choose the which graph in the input file.\n\
         The first graph is number 1. (default 1)\n\
    -v  be verbose\n\
    -h  show this help text\n"

#define HASH_KEY 1

#define MAX(x, y) (((x) > (y)) ? (x) : (y))
#define MIN(x, y) (((x) < (y)) ? (x) : (y))

int verbose = 0;
#define print(...) if (verbose) printf(__VA_ARGS__)

#+end_src

** graph data structure
#+name: graphs
#+begin_src c
typedef struct mgraph
{ // an undirected multigraph
  int *g;
  int n;
} mgraph;

typedef struct medge
{
  int i;
  int j;
  int m; //multiplicity
} edge;

#define MG_IDX(mg,i,j) mg->g[j + i*mg->n]

extern int mg_get_edge_mult(mgraph *mg, int i, int j);
extern void mg_add_medge(mgraph *mg, edge e);
extern void mg_rem_medge(mgraph *mg, edge e);
extern void mg_contract_edge(mgraph *mg, edge e);

inline int mg_get_edge_mult(mgraph *mg, int i, int j)
{
  return MG_IDX(mg,i,j);
}
inline void mg_add_medge(mgraph *mg, edge e)
{
  MG_IDX(mg,e.i,e.j) += e.m;
  MG_IDX(mg,e.j,e.i) += e.m;
}
inline void mg_rem_medge(mgraph *mg, edge e)
{
  MG_IDX(mg,e.i,e.j) -= e.m;
  MG_IDX(mg,e.j,e.i) -= e.m;
}
inline void mg_contract_edge(mgraph *mg, edge e)
{
  int m;
  for (int j = 0; j < mg->n; j++)
    if ((m = mg_get_edge_mult(mg,e.j,j)))
    {
      mg_rem_medge(mg, (edge){.i = e.i, .j = j, .m = m});
      mg_add_medge(mg, (edge){.i = e.i, .i = j, .m = m});
    }
}


/*
#define MG_ARC(mg,i,j) mg->g[j + i*mg->n]

#define MG_GET_EMULT(mg,i,j) MG_ARC(mg,i,j)

#define MG_ADD_MEDGE(mg,e) do { \
    MG_ARC(mg, e.i, e.j) += e.m; \
    MG_ARC(mg, e.j, e.i) += e.m; \
  } while (0)

#define MG_REM_MEDGE(mg,e) do { \
    MG_ARC(mg, e.i, e.j) -= e.m; \
    MG_ARC(mg, e.j, e.i) -= e.m; \
  } while (0)
*/

mgraph *
empty_mgraph(int n)
{
  mgraph *g = (mgraph *)malloc(sizeof(mgraph));
  g->n = n;
  g->g = (int *)calloc(n*n, sizeof(int));
  return g;
}
mgraph *
copy_mgraph(mgraph *g)
{
  mgraph *cg = empty_mgraph(g->n);
  memcpy(cg->g, g->g, (g->n*g->n) * sizeof(int));
  return g;
}

mgraph *
nautygraph_to_mgraph(graph *gg, int n, int m)
{
  mgraph *mg = empty_mgraph(n);
  for (int i = 0; i < n; i++)
    for (int j =0; j < n; j++)
      if (ISELEMENT(GRAPHROW(gg,i,m),j)) MG_IDX(mg,i,j) = 1;
  DYNFREE(gg,n);
  return mg;
}

graph *
mgraph_to_nauttygraph(mgraph *mg)
{
  return NULL;
}

sparsegraph *
mgraph_to_sparsegraph(mgraph *mg)
{
  return NULL;
}

void
free_mgraph(mgraph *g)
{
  free(g->g);
  free(g);
}

typedef struct mgraph_info
{
  int props;
  mgraph **comps;
  int comps_len;
} mgraph_info;

void
free_mgraph_info(mgraph_info *info)
{
  for (int i = 0; i < info->comps_len; i++)
    free_mgraph(info->comps[i]);
  free(info->comps);
  free(info);
}
#+end_src

** polynomial data structure
#+name: polys
#+begin_src c
typedef struct poly
{ // a polynomial
  long *c;
  int y_deg;
  int x_deg;
} poly;

poly *
new_poly(int x_deg, int y_deg)
{
  poly *p = (poly *)calloc(1, sizeof(poly));
  p->c = (long *)calloc((x_deg+1)*(y_deg+1), sizeof(long));
  p->x_deg = x_deg;
  p->y_deg = y_deg;
  return p;
}

void
free_poly(poly *p)
{
  free(p->c);
  free(p);
}

long *
poly_coeff(poly *A, int x, int y)
{
  if (x > A->x_deg) return 0;
  if (y > A->y_deg) return 0;
  return &A->c[y + x*A->y_deg];
}

void
print_poly(FILE *fout, poly *p)
{
  for (int x = 0; x <= p->x_deg; x++)
    for (int y = 0; y <= p->y_deg; y++)
      fprintf(fout, "%ldx^%dy^%d\n", *poly_coeff(p, x, y), x, y);
}

poly *
poly_add(poly *A, poly *B)
{
  poly *C = new_poly(MAX(A->x_deg, B->x_deg), MAX(A->y_deg, B->y_deg));
  for (int x = 0; x <= C->x_deg; x++)
    for (int y = 0; y <= C->y_deg; y++)
      ,*poly_coeff(C, x, y) = *poly_coeff(A, x, y) + *poly_coeff(B, x, y);
  free_poly(A); free_poly(B);
  return C;
}

poly *
poly_mult(poly *A, poly *B)
{
  poly *C = new_poly((A->x_deg + B->x_deg), (A->y_deg + B->y_deg));

  for (int ax = 0; ax <= A->x_deg; ax++)
    for (int ay = 0; ay <= A->y_deg; ay++)
      for (int bx = 0; bx <= B->x_deg; bx++)
        for (int by = 0; by <= B->y_deg; by++)
          ,*poly_coeff(C, ax+bx, ay+by) = ( (*poly_coeff(A, ax, ay)) *
                                           (*poly_coeff(B, bx, by)) );
  free_poly(A); free_poly(B);
  return C;
}
#+end_src

** tarjan graph search
#+name: tarjan
#+begin_src c
/*
  poly * tutte(mgraph *g);

  mgraph_info *
  search_mgraph(mgraph *g)
  {


  }
,*/

#+end_src

** reductions
#+name: reductions
#+begin_src c
edge select_edge(mgraph *g)
{
  int m;
  for (int i = 0; i < g->n; i++)
    for (int j = 0; j < g->n; j++)
      if ((m = mg_get_edge_mult(g,i,j))) return (edge){.i = i, .j = j, .m = m};

  fprintf(stderr, "select_edge called on empty graph\n");
  return (edge){.i = -1, .j = -1, .m = -1};
}

boolean
edge_is_loop(mgraph *g, edge e)
{
  if (e.i == e.j) return TRUE;
  return FALSE;
}

int
bridge_helper(mgraph *g, int a, int c)
{
/*
  if (a == c) return 1;
  else
    for (int i = 0; i < g->n; i++)
      if (ARC(g,a,i) && bridge_helper(g, a, i)) return 1;
,*/
  return 0;
}

int
edge_is_bridge(mgraph *g, edge e)
{
/*
  for (int i = 0; i < g->n; i++)
    if (ARC(g,e.a,i) && (i != e.b))
      if (bridge_helper(g, e.b, i)) return 0;
,*/
  return 1;
}

/*
poly *
reduce_components(mgraph *g, mgraph_info *info)
{
  return NULL;
}

poly *
reduce_trees(mgraph *g, mgraph_info *info)
{
  return NULL;
}

poly *
reduce_multiears(mgraph *g, mgraph_info *info)
{
  return NULL;
}
poly *
reduce_loops(mgraph *g, mgraph_info *info)
{
  return NULL;
}
poly *
reduce_multiedges(mgraph *g, mgraph_info *info)
{
  return NULL;
}

poly *
reduce_edge_heuristic(mgraph *g, mgraph_info *info)
{
  edge e = select_edge(g);
  poly *pd = tutte(delete_edge(g, e));
  poly *pc = tutte(contract_edge(g, e));
  return poly_add(pc, pd);
}
,*/


#+end_src

** tutte
#+name: tutte
#+begin_src c
poly *
tutte(mgraph *g)
{

  // if hashgraph(g) in cache: return cache[key]
  //fcanonise(g, m, n, h, NULL, FALSE);
  //long hash = hashgraph(g, m, n, HASH_KEY);
  //char* graph_str = ntog6(g, m, n);
  //printf("%s->%ld\n\n", graph_strg, hashg);
  //else

  poly *p;
  /*
  mgraph_info *info = search_mgraph(g);

  if      (info->props & NOT_CONNECTED) p = reduce_components(g, info);
  else if (info->props & NOT_CONNECTED) p = reduce_trees(g, info);
  else if (info->props & NOT_CONNECTED) p = reduce_multiears(g, info);
  else if (info->props & NOT_CONNECTED) p = reduce_loops(g, info);
  else if (info->props & NOT_CONNECTED) p = reduce_multiedges(g, info);
  else                                  p = reduce_edge_heuristic(g, info);

  // cache[hashgraph(g)] = p
  free_mgraph_info(info);
  ,*/

  edge e = select_edge(g);
  if (g->n == 0)
    {
      p = new_poly(0,0);
      ,*poly_coeff(p, 0, 0) = 1;
      free_mgraph(g);
    }
  else
    {
      if (edge_is_loop(g, e))
        {
          mg_rem_medge(g, e);
          p = tutte(g);
          poly *y = new_poly(0,1);
          ,*poly_coeff(y, 0, 0) = 0; *poly_coeff(y, 0, 1) = 1;
          p = poly_mult(p, y);
        }
      else if (edge_is_bridge(g, e))
        {
          mg_contract_edge(g, e);
          p = tutte(g);
          poly *x = new_poly(1,0);
          ,*poly_coeff(x, 0, 0) = 0; *poly_coeff(x, 1, 0) = 1;
          p = poly_mult(p, x);
        }
      else {
        mgraph *gc = copy_mgraph(g);
        mg_rem_medge(g, e);
        poly *pd = tutte(g);
        mg_contract_edge(gc, e);
        poly *pc = tutte(gc);
        p = poly_add(pc, pd);
      }
    }

  return p;
}
#+end_src

** main
#+name: main
#+begin_src c
int
main(int argc, char *argv[])
{
  char* infile = NULL;
  char* outfile = NULL;
  FILE* fin = NULL;
  FILE* fout = NULL;
  int n,m;
  int codetype;
  boolean digraph;

  int c;
  long position = 1;

  while ((c = getopt (argc, argv, "hvp:")) != -1)
    switch (c)
      {
      case 'h':
        printf("%s\n%s", USAGE, HELPTEXT);
        return 0;
      case 'q':
        verbose = 1;
        break;
      case 'p':
        position = strtol(optarg,(char **)NULL, 10);
        break;
      case '?':
        printf("%s", USAGE);
        return 1;
      default:
        abort ();
      }
  if (optind < (argc-2))
    {
      fprintf(stderr, "Too many non-option arguments\nUse tutte -h for help\n%s", USAGE);
      return 1;
    }
  if (optind == (argc-2)) {infile = argv[optind]; outfile = argv[optind+1];}
  if (optind == (argc-1)) infile = argv[optind];

  fin = opengraphfile(infile, &codetype, 0, position);
  if (fin == NULL)
    {fprintf(stderr, "error opening file"); exit(1);}
  graph *gg = readgg(fin, NULL, 0, &m, &n, &digraph);
  if (digraph) {fprintf(stderr, "digraphs not supported"); exit(1);}
  nauty_check(WORDSIZE,m,n,NAUTYVERSIONID);
  print("n = %d, m = %d\n", n, m);

  mgraph *mg = nautygraph_to_mgraph(gg,n,m);
  poly *p = tutte(mg);

  if (outfile == NULL)
    {
      fout = fopen(outfile,"w");
      if (fout == NULL) {fprintf(stderr,"Can't open %s\n", outfile); exit(1);}
    }
  else fout = stdout;

  print_poly(fout, p);
  free_poly(p);

  return 0;
}
#+end_src

** tangle
#+begin_src c :noweb yes :tangle tutte.c
<<includes>>
<<macros>>
<<graphs>>
<<polys>>
<<tarjan>>
<<reductions>>
<<tutte>>
<<main>>
#+end_src


* local lisp variables                                             :noexport:
;; Local Variables:
;; eval: (add-hook 'after-save-hook (lambda ()(org-babel-tangle)) nil t)
;; End:
